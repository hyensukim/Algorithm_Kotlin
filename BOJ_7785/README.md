# 문제: 회사에 들어온 사람

## 문제 설명
회사에 출입하는 사람들의 기록이 주어질 때, 마지막에 회사에 있는 사람들을 구하는 문제입니다.

**입력:**
- 첫째 줄: 정수 N (출입 기록의 수, 1 ≤ N ≤ 100,000)
- 다음 N개 줄: 회사 직원의 이름과 출입 상태 ("enter" 또는 "leave")

**출력:**
- 마지막에 회사에 있는 사람들의 이름을 사전 역순(내림차순)으로 한 줄에 하나씩 출력

## 풀이 접근법

### 알고리즘
1. **입력 읽기**: 첫 줄에서 N(출입 기록 수)을 파싱
2. **상태 관리**: HashSet을 사용하여 현재 회사에 있는 사람 추적
    - "enter": 해당 인물을 Set에 추가
    - "leave": 해당 인물을 Set에서 제거
3. **결과 정렬 및 출력**: 최종적으로 Set에 남은 사람들을 사전 역순으로 정렬하여 출력

### 시간 복잡도
- **입력 처리**: O(N) - N개의 출입 기록 읽기
- **Set 연산**: O(N) - 각 add/remove 연산은 평균 O(1)
- **정렬**: O(K log K) - K는 최종 회사에 있는 사람의 수 (K ≤ N)
- **전체**: O(N + K log K)

### 공간 복잡도
- O(K) - 회사에 있는 사람들을 HashSet에 저장

## 구현 세부사항 (Main.kts)

**핵심 포인트:**
- **1-2번 줄**: 표준 입력에서 N을 읽기
- **4번 줄**: HashSet을 사용하여 현재 회사에 있는 사람 관리
- **5-8번 줄**: 각 출입 기록을 파싱하여 입장하면 추가, 퇴장하면 제거
- **10번 줄**: Set을 사전 역순으로 정렬한 후 한 줄에 하나씩 출력

**자료구조 선택:**
- `HashSet`을 사용하는 것이 성능에 결정적
- 중복 없이 고속의 추가/제거 연산 제공 (평균 O(1))
- 같은 사람이 여러 번 출입할 수 있으므로 List로는 중복 처리 어려움
- Set은 자동으로 중복을 무시하여 최종 상태만 저장

## 이 풀이가 작동하는 이유

이 문제는 본질적으로 **동적 멤버십 관리** 문제입니다. 최적의 접근법은:
1. 회사 직원들의 현재 상태를 HashSet에 유지
2. 각 출입 기록마다 상태 업데이트
3. 최종적으로 Set에 남은 사람들이 회사에 있는 사람들

HashSet을 사용하면 각 연산이 평균적으로 상수 시간에 수행되므로, 최대 입력 크기에서도 효율적인 솔루션을 만들 수 있습니다.

## 대안적 접근법
1. **HashMap 사용 (O(N))**: 이름을 키로, 상태를 값으로 저장 - 작동하지만 Set보다 복잡함
2. **배열 + 선형 탐색**: 모든 사람의 이름을 미리 알아야 하므로 부적합
3. **정렬된 배열**: 삽입/삭제 시 O(N)이 되어 비효율적

## 테스트 케이스 예제

**입력:**
```
4
Jihoo enter
Sunhwan enter
Jihoo leave
Gujin enter
```

**출력:**
```
Sunhwan
Gujin
```

**설명:**
- Jihoo가 입장 (회사: {Jihoo})
- Sunhwan이 입장 (회사: {Jihoo, Sunhwan})
- Jihoo가 퇴장 (회사: {Sunhwan})
- Gujin이 입장 (회사: {Sunhwan, Gujin})
- 최종적으로 회사에 있는 사람: Sunhwan, Gujin (사전 역순 출력)