## 문제: BOJ 14425 - 문자열 집합

### 문제 설명
N개의 문자열로 이루어진 집합 S가 주어지고, M개의 문자열이 주어질 때, M개의 문자열 중 집합 S에 포함되어 있는 것의 개수를 구하는 문제입니다.

**입력:**
- 첫째 줄: 두 정수 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000)
- 다음 N개 줄: 집합 S에 포함될 문자열
- 다음 M개 줄: 검사할 문자열

**출력:**
- M개의 문자열 중 집합 S에 포함되어 있는 문자열의 개수를 출력

### 풀이 접근법

#### 알고리즘(algorithm)
1. **입력 읽기**: 첫 줄에서 N(집합 크기)과 M(검사할 개수)을 파싱
2. **집합 구성**: N개의 문자열을 HashSet에 저장하여 O(1) 검색 시간 확보
3. **일치 개수 세기**: M개의 문자열 각각에 대해 집합에 존재하는지 확인
4. **결과 출력**: 일치하는 문자열의 총 개수 출력

#### 시간 복잡도
- **집합 구성**: O(N) - N개의 문자열 읽기 및 삽입
- **검색**: O(M) - M개의 문자열을 O(1) 평균 시간에 검색
- **전체**: O(N + M)

#### 공간 복잡도
- O(N) - N개의 문자열을 HashSet에 저장

### 구현 세부사항 (Main.kts)

**핵심 포인트:**
- **5번 줄**: N개의 입력 문자열을 `Set`으로 변환하여 효율적인 검색 구현
- **6번 줄**: M개의 검사할 문자열을 리스트에 저장
- **9-11번 줄**: 검사할 문자열을 순회하며 `contains()`를 사용해 일치 개수 세기
- **12번 줄**: 최종 개수 출력

**자료구조 선택:**
- `List` 대신 `Set`을 사용하는 것이 성능에 결정적
- Set은 평균 O(1) 검색 제공 vs List의 O(N)
- N, M이 최대 10,000까지 가능하므로 이 최적화로 시간 초과 방지

### 이 풀이가 작동하는 이유

이 문제는 본질적으로 **멤버십 테스트** 문제입니다. 최적의 접근법은:
1. 기준 문자열들을 해시 기반 자료구조(Set)에 저장
2. 각 테스트 문자열을 집합에서 검색

HashSet을 사용하면 각 검색이 평균적으로 상수 시간에 수행되므로, 최대 입력 크기에서도 효율적인 솔루션을 만들 수 있습니다.

### 대안적 접근법
1. **브루트 포스 (O(N×M))**: 각 검사 문자열을 N개 문자열 전체와 비교 - 너무 느림
2. **정렬 + 이진 탐색 (O(N log N + M log N))**: 배열 정렬 후 이진 탐색 사용 - 작동하지만 더 느림
3. **트라이(Trie)**: 사용 가능하지만 접두사 매칭이 필요 없는 이 문제에는 과함

### 테스트 케이스 예제

**입력:**
```
5 11
baekjoononlinejudge
startlink
codeplus
sundaycoding
codingsh
baekjoon
codeplus
codeminus
startlink
starlink
sundaycoding
codingsh
codinghs
sondaycoding
startrink
icerink
```

**출력:**
```
4
```

**설명:**
일치하는 문자열: codeplus, startlink, sundaycoding, codingsh